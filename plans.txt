                   

Inversion of Control, IoC принцип объектно-ориентированного - construction and management objects
Spring Container thrue
XML configuration (legacy)
<beans>
	<bean id="myCoach" class="com.demo.springdemo.BaseballCoach">
	</bean>
</beans>
Java Annotation
Java Source Code

Create Container:
– ClassPathXmlApplicationContext
– AnnotationConfigApplicationContext
– GenericWebApplicationContext
– FileSystemXmlApplicationContext
Загружает данные о бине из XML файла. При использовании этой реализации в конструкторе необходимо указать полный адрес конфигурационного файла.
– WebXmlApplicationContext
Эта реализация ApplicationContext получает необходимую информацию из веб-приложения.

XML CONFIGURATION

Constructor injections
Setter injections (инъенкция в метод)
и добавить в 
<beans>
	<bean id="myCoach" class="com.demo.springdemo.BaseballCoach">
	//с помощью конструктора
	<constructor-arg ref="myFortuneService"/>
	//с помощью метода setFortuneService
	<property name="FortuneService" ref="myFortuneService"/>
	//с помощью полей класса
	<property name="team" value="Sunrisers Hyderabad"/>
	</bean>
</beans>


Можно читать прямо из property.file
+ прописать
   <context:property-placeholder location="classpath:sport.properties"/>
   <property name="emailAddress" value="${foo.team}"/>

BEAN SCOPES
@Component
@Scope("prototype")
<bean id="myCoach" class="com.demo.springdemo.BaseballCoach" scope="singleton | prototype | request | session | global-session">

singleton - single shared
prototype - new bean instance for each container request
request - HTTP request thrue web
session - for HTTP web session
global-session - global HTTP web session

BEAN LIFECYCLES
<bean id="myCoach" class="com.demo.springdemo.BaseballCoach" scope="prototype" init-method="doMyMethod" destroy-method="doAnotherMethod">


ANNOTATIONS CONFIGURATION
<bean id="myCoach" class="com.demo.springdemo.BaseballCoach" scope="prototype" init-method="doMyMethod" destroy-method="doAnotherMethod">
//должна быть пометка
<context:component-scan base-package="com.demo.springdemo"/>
+
//должна быть аннотация
@Component("oneCoach")
public class SomeClass(){...
+
добавляется бин в контейнер
Coach theCoach = context.getBean("oneCoach", Coach.class);

Autowiring:
1) Constructor Injection
2) SetterInjection
3) MethodInjection
4) FieldInjection
5) Qualifiers for Dependency Injection

1) Constructor Injection
@Component
public class TennisCoach implements Coach {
	
	private FortuneService fortuneService;
	
	@Autowired
	public TennisCoach(FortuneService theFortuneService) {
		fortuneService = theFortuneService;
	}
2) SetterInjection
	//setter injection
	@Autowired
	public void setFortuneService(FortuneService theFortuneService) {
		System.out.println(">>>>>>>>>>Tennis coach setter method");
		fortuneService = theFortuneService;
	}
3) MethodInjection
	//method injection
	@Autowired
	public void doFortuneService(FortuneService theFortuneService) {
		System.out.println(">>>>>>>>>>Tennis coach method");
		fortuneService = theFortuneService;
	}
4) FieldInjection
@Autowired
private FortuneService fortuneService;

5) Qualifiers for Dependency Injection
используется, когда надо много сервисов имплементимровать
@Qualifier("happyFortuneService") - это уникальный bean ID
может добавляться ко всем видам аннотаций

@Scope ANNOTATION
Default is singleton
@Scope("prototype") - original for each request

LifeCycle for beans
@PostConstruct //будет запущен, когда сервер загрузит сервлет, и будет вызываться сервером только один раз,
@PreConstruct //будет запущен, когда сервер удалит сервлет, и будет вызываться сервером только один раз, подобно методу
    private void postConstruct() {
.................
@PreDestroy

JAVA CONFIGURATION
1) AnnotationConfigApplicationContext context  = new AnnotationConfigApplicationContext(SportConfig.class);
2) @Configuration - над классом, который будет конфигурировать другие
3) @ComponentScan("com.demo.springdemo")
   public class SportConfig {...

3) определить @Bean и зависимости:
@Bean
public SomeClass instance(){
return new HappyFortuneService();
}
тут тоже есть properties файл
загружается через:
@PropertySource("classpath:sport.properties")
потом вставляется так:
@Value("${foo.email}")
private String email;

Dispatcher Servlet есть в Spring MVC
добавляется в WEB-INF/servlet.xml
потом
создаем @Controller
создаем @RequestMapping...
{
return file.jsp //возвращает htmp файл из WEB-INF/view
}

SPRING MVC
@RequestMapping(value="someValue", RequestMethod.GET)


HIBERNATE
возможно сохранять объекты в базе

Student someStudent = new Student("name", "secondname", "faculty");
int theId = (Integer)session.save(someStudent);

и удалять

Student myStudent = session.get(Student.class, theId);

запрос

Query query = session.createQuery("from Student");
List <Student> students = query.list();

Hibernate тоже работает как через XML (легаси), так и через Java аннотации
Hibernate mapping
@Entity
@Table(name="student")
public class Student(){
	@Id
	@Column(name="id")
	private int id;
	
	@Column(name="first_name")
	private String firstName;
....
У Hibernate есть SessionFactory и Session(более маложивущие)
JPA предоставляет разработчикам четыре стратегии генерации первичных ключей, которые определены в классе перечисления GenerationType, включая GenerationType.TABLE, GenerationType.SEQUENCE, GenerationType.IDENTITY и GenerationType.AUTO. Четыре стратегии генерации первичного ключа описаны ниже.
1. GenerationType.TABLE
Механизм персистентности генерирует первичный ключ через определенную таблицу в реляционной базе данных. Преимущество этой стратегии заключается в том, что она не зависит от внешней среды и конкретной реализации базы данных.
Если вы не укажете список последовательностей, будет создан список последовательностей по умолчанию, автоматически будут сгенерированы имена столбцов в таблице и в базе данных будет сгенерирована таблица с именем sequence (SEQ_NAME, SEQ_COUNT). Список последовательностей обычно содержит только два поля: первое поле - это название стратегии генерации, а второе поле - максимальный порядковый номер таблицы отношений, которая будет постепенно накапливаться при вставке данных. 
    @Id
    @GeneratedValue(strategy = GenerationType.TABLE, generator = "roleSeq")
    @TableGenerator(name = "roleSeq", allocationSize = 1, table = "seq_table", pkColumnName = "seq_id", valueColumnName = "seq_count")
    private Integer id;
2. GenerationType.SEQUENCE
В некоторых базах данных саморазвитие первичного ключа не поддерживается, например Oracle, который предоставляет механизм, называемый «последовательность» для генерации первичных ключей. На этом этапе GenerationType.SEQUENCE можно использовать в качестве стратегии генерации первичного ключа. Недостатком этой стратегии является полная противоположность TABLE: поскольку только некоторые базы данных (Oracle, PostgreSQL, DB2) поддерживают объекты последовательностей, эта стратегия обычно не применяется к другим базам данных. Точно так же эта стратегия обычно используется с другой аннотацией @SequenceGenerator, аннотация @SequenceGenerator задает последовательность для генерации первичного ключа. Затем JPA создаст последовательность на основе содержимого аннотации (или использует существующую последовательность). Если последовательность не указана, последовательность SEQ_GEN_SEQUENCE будет сгенерирована автоматически.
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "menuSeq")
    @SequenceGenerator(name = "menuSeq", initialValue = 1, allocationSize = 1, sequenceName = "MENU_SEQUENCE")
    private Integer id;
3. GenerationType.IDENTITY
Этот вид стратегии генерации первичного ключа обычно известен как саморазвитие первичного ключа. Когда база данных вставляет данные, она автоматически присваивает значение первичному ключу. Например, MYSQL может объявить «auto_increment» при создании таблицы, чтобы указать саморазвитие первичного ключа. Эта стратегия обеспечивает поддержку в большинстве баз данных (указанные методы или ключевые слова могут отличаться), но есть еще несколько баз данных, которые не поддерживают ее, поэтому переносимость немного ухудшена. Чтобы использовать стратегию генерации первичного ключа для саморазвития, вам нужно только объявить policy = GenerationType.IDENTITY. 
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;
4. GenerationType.AUTO
тратегия генерации первичного ключа передается механизму персистентности, а механизм персистентности выбирает одну из трех стратегий генерации первичного ключа в соответствии с базой данных. Этот тип стратегии генерации первичного ключа используется чаще, так как стратегия генерации JPA по умолчанию - GenerationType.AUTO, при использовании этой стратегии вы можете явно указать @GeneratedValue (Strategy = GenerationType.AUTO) или напрямую @GeneratedValue
Похож на

    @GeneratedValue(strategy = GenerationType.AUTO)
    private Integer id;

или

    @GeneratedValue
    private Integer id;
    
HQL
List<Students> theStudents = session
                             .createQuery("from Student s where s.lastName='Doe'")
                             .getResultList();   
                             
Entity это легковесный хранимый объект бизнес логики (persistent domain object). Основная программная сущность это entity класс, который так же может использовать дополнительные классы, который могут использоваться как вспомогательные классы или для сохранения состояния еntity.                             
        @Entity
public class Customer implements Serializable {
@Id protected Long id;
protected String name;
@Embedded protected Address address;
protected PreferredStatus status;
@Transient protected int orderCount;
public Customer() {}
public Long getId() {return id;}
protected void setId(Long id) {this.id = id;}
public String getName() {return name;}
public void setName(String name) {this.name = name;}
…
}

Любой Entity имеет перманентный идентификатор
– Он отображается в первичный ключ в таблице
● Идентификатор — примитивный тип
– @Id—одиночное поле/свойство в Entity
классе
– @GeneratedValue—значение может
генерироватся автоматически, используя
различные стратегии (SEQUENCE, TABLE,
IDENTITY, AUTO)
● Идентификатор – пользовательский класс
– @EmbeddedId—одиночное поле/свойство в Entity
классе
– @IdClass—соответствует множеству полей в
Entity классе

Управляет жизненным циклом Entity
объектов
– persist() - помещает объект в БД
– remove() - удаляет объект из БД
– merge() - синхронизирует с БД состояние
отсоединенного объекта
– refresh() - обновляет из БД состояние
объекта 


Операция Persist
public Order createNewOrder(Customer customer) {
 // Создаем новый объект
Order order = new Order(customer);
 // После вызова метода persist() объект меняет свой
 // статус на управляемый. Во время очередной
 // операции записи в БД объект будет помещен в БД.
entityManager.persist(order);
return order;
}

Операции Find и Remove
public void removeOrder(Long orderId) {
Order order =
 entityManager.find(Order.class, orderId);
 // Объект будет удален из БД при очередной
 // операции записи в БД. Доступ к удаленному
 // объекту приводит к непредсказуемым
 // результатам.
entityManager.remove(order);
}

Операция Merge
public OrderLine updateOrderLine(OrderLine orderLine) {

 // Метод merge возвращает управляемую копию
 // переданного отсодиненного объекта. Если состояние
 // отсоединного объекта было изменено, то изменения
 // будут отражены в возвращаемой копии.
return entityManager.merge(orderLine);
}


Типы EntityManager
● Управляемый контейнером EntityManager (Java
EE)
● Управляемый приложением EntityManager (Java SE)

Как создать EntityManager
● Разные типы EntityManager создаются по
разному
– Управляемый контейнером EntityManager
(Java EE) создается контейнером и
становится доступным для приложения
через механизм инъекций Используется
аннотация @PersistenceContext.
– Управляемый приложением EntityManager
(Java SE) создается и закрывается
(уничтожается) приложением. 

Persistence Unit
● Все Entity объекты управляемые
определенным EntityManager
определяюсь при помощи Persistence Unit
● persistence.xml определяет один или
несколько Persistence Unit
<persistence-unit name="OrderManagement">
<mapping-file>mappings.xml</mapping-file>
<jar-file>order.jar</jar-file>
<transaction-type>JTA</transaction-type>
</persistence-unit>

У Entity объекта существует четыре статуса жизненного цикла: new, managed, detached, или removed. Их описание
1) new — объект создан, но при этом ещё не имеет сгенерированных первичных ключей и пока ещё не сохранен в базе данных,
2) managed — объект создан, управляется JPA, имеет сгенерированные первичные ключи,
3) detached — объект был создан, но не управляется (или больше не управляется) JPA,
4) removed — объект создан, управляется JPA, но будет удален после commit'a транзакции.
5) refresh- reload/sync

Mapping- соотношение между таблицами и связи между ними   

@OneToOne
@JoinColumn(name="some name")

CascadeType.PERSIST - связанные сущности тоже сохраняются
CascadeType.MERGE - 
CascadeType.REMOVE
CascadeType.REFRESH
CascadeType.DETACH
CascadeType.ALL - все вышеперечисленные

MVC делается так: 
1) создается Entity или класс Модель (энтитит без аннотаций. типа сущностного интерфейса)
public class Developer {
    private int id;
    private String name;
    private String specialty;
    private int experience;
    ..................
потом в Контроллере прописыватеся так(тут пример с РЕСТ примером)
    @RequestMapping(value = "/addDeveloper", method = RequestMethod.POST)
    public String addStudent(@ModelAttribute("mvc-dispatcher") Developer developer,
                             ModelMap model) {
        model.addAttribute("id", developer.getId());
        model.addAttribute("name", developer.getName());
        model.addAttribute("specilaty", developer.getSpecialty());
        model.addAttribute("experience", developer.getExperience());
Добавляется аннтоация Model
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.ui.ModelMap;
в конце выдается view в виде JSP
 return "result";



@OneToOne(cascade=CascadeType.ALL)
у него есть Bi-directional отношение
двунаправленные (bidirectional): когда классы ссылаются друг на друга взаимно.
Вообще для разрешения подобных противоречий в Hibernate есть понятие owning side (главная сторона). Неглавная сторона помечается свойством mappedBy, ее ссылки имеют второстепенную важность. А главная сторона имеет приоритет.
Связь один-к-одному может быть двунаправленной. В двунаправленных отношениях одна из сторон (и только одна) должна быть владельцем и нести ответственность за обновление связанных полей.


тогда нужно добавить над классом от которого тоже ждут отношения

@OneToOne(mappedBy="instructorDetail")
private Instructor instructor; //добавлено создание экземпляра целевого класса

а из запрашивающего досутп класса надо добавить
public class Instructor{.....

@OneToOne(cascade=CascadeType.ALL)
@JoinColumn(name="instructor_detail_id")
private InstructorDetail someDetails; //тут тоже создается


@OneToMany
сначаланадо обработать "many"
public class Course{
    @ManyToOne
    @JoinColumn(name="instructor_id", cascade={CascadeType.PERSIST,
                                           CascadeType.MERGE,
                                           CascadeType.DETACH,
                                           CascadeType.REFRESH
                                          })
    private Instructor instructor;
}

далее

public class Instructor{
@OneToMany(mappedBy="instructor", cascade={CascadeType.PERSIST,
                                           CascadeType.MERGE,
                                           CascadeType.DETACH,
                                           CascadeType.REFRESH
                                          })
private List<Course> courses;

bi-directional method link
class Instructor{
      public void add(Course tempCourse){
      if(coursec == null)
         {
         coursec = new ArrayList<>();
         }
         courses.add(tempCourse);
         tempCourse.setInstructor(this);
      }
      
}


Lazy loading Hibernate
@Entity
@Table(name="instructor")
public class Instructor{
	@OneToMany(fetch=FetchType.LAZY, mappedBy="instructor")
	private List<Course> courses;
	
}
To retrieve lazy data you need to create Hibernate session
а потом уже возвращать или через сессию или через HQL


@OneToMany uni-directional
это с использованием SQL деректив (добавляет каскадинг):

  PRIMARY KEY (`id`),
  KEY `FK_DETAIL_idx` (`instructor_detail_id`),
  CONSTRAINT `FK_DETAIL` 
  FOREIGN KEY (`instructor_detail_id`) 
  REFERENCES `instructor_detail`


@ManyToMany
В энтити прописать
	@ManyToMany(fetch=FetchType.LAZY,
			cascade= {CascadeType.PERSIST, CascadeType.MERGE,
			 CascadeType.DETACH, CascadeType.REFRESH})
	@JoinTable(
			name="course_student",
			joinColumns=@JoinColumn(name="course_id"),//!!!!!!!!
			inverseJoinColumns=@JoinColumn(name="student_id")//!!!!!!!!
			)
И сделать связь в другой энтити	
	@JoinTable(
			name="course_student",
			joinColumns=@JoinColumn(name="student_id"),//!!!!!!!!
			inverseJoinColumns=@JoinColumn(name="course_id")//!!!!!!!!
			)



Приложения делаются следующим образом:
создаются файлы:
Customer.java = Entity
CustomerDAO.java = Model
CustomerDAOImpl.java = ModelRealisation
CustomerController.java = Controller
все выводится на фронт.

Аннотация @Transactional определяет область действия одной транзакции БД. Транзакция БД происходит внутри области действий persistence context. Persistence context в JPA является EntityManager, который использует внутри класс Session ORM-фреймворка Hibernate (если использовать Hibernate как persistence провайдер).
Один объект EntityManager может быть использован несколькими транзакциями БД.
Сама аннотация транзакции определяет область действия одной транзакции базы данных. Транзакция базы данных происходит внутри контекста персистентности .

Контекст персистентности находится в JPA EntityManager , реализованном внутренне с использованием Hibernate Session (при использовании Hibernate в качестве поставщика персистентности).

Контекст постоянства — это просто объект синхронизатора, который отслеживает состояние ограниченного набора объектов Java и гарантирует, что изменения в этих объектах в конечном итоге сохраняются обратно в базу данных.

Это совершенно другое понятие, чем понятие транзакции базы данных. Один Entity Manager может использоваться для нескольких транзакций базы данных , и это на самом деле часто.
Обычно @Transactional находится в service layer

Spring AOP - cross-cutting logic
Аннотации
@Aspect
@EnableAspectJAutoProxy
@Pointcut()
@Befor("")
@Order()
@AfterReturning
@AfterThrowing
@Afret
@Around

Аспектно-ориентированное программирование (АОП) — это парадигма программирования являющейся дальнейшим развитием процедурного и объектно-ориентированного программирования (ООП). Идея АОП заключается в выделении так называемой сквозной функциональности. И так все по порядку, здесь я покажу как это сделать в Java — Spring @AspectJ annotation стиле (есть еще schema-based xml стиль, функциональность аналогичная).

Выделении сквозной функциональности

Т.е. есть функциональность которая затрагивает несколько модулей, но она не имеет прямого отношения к бизнес коду, и ее хорошо бы вынести в отдельное место, это и показано на рисунке выше.

Join point — следующее понятие АОП, это точки наблюдения, присоединения к коду, где планируется введение функциональности.

Pointcut — это срез, запрос точек присоединения, — это может быть одна и более точек. Правила запросов точек очень разнообразные, на рисунке выше, запрос по аннотации на методе и конкретный метод. Правила можно объединять по &&, ||,!

Advice — набор инструкций выполняемых на точках среза (Pointcut). Инструкции можно выполнять по событию разных типов:

Before — перед вызовом метода
After — после вызова метода
After returning — после возврата значения из функции
After throwing — в случае exception
After finally — в случае выполнения блока finally
Around — можно сделать пред., пост., обработку перед вызовом метода, а также вообще обойти вызов метода.

на один Pointcut можно «повесить» несколько Advice разного типа.

Aspect

image

Aspect — модуль в котором собраны описания Pointcut и Advice.
Сейчас приведу пример и окончательно все встанет (или почти все) на свои места. Все знаем про логирование кода который пронизывает многие модули, не имея отношения к бизнес коду, но тем не менее без него нельзя. И так отделяю этот функционал от бизнес кода.

GroupID- название фирмы
ArtefactID- название проекта
pom.file - project object model file

Spring Security
Authentication- получить вход
Authorization -получить роль

сначала создается 
UserBuilder users = User.withDefaultPasswordEncoder();

есть возможность криптовать пароли

Spring REST (representational state transfer)
Генерирует JSON а его в POJO маппером
@PathVariable
@JsonIgnoreProperties(ignoreUnknown=true)

@RestController
@RequestMapping("/test")
public class SomeClass(){
	
	@GetMapping("/hello")
	public string sayHello(){
	}
}

Для ошибок @ExceptionHandler и @ControllerAdvice
для Актуатора надо добавить в депенденси дев тул.

в проект может быть добавлен файл конфигураций в 
папку resorses добавляется файл application.properties

Spring Data REST - это часть проекта Spring Data, которая позволяет обращаться к JPA-репозиториям как к REST-сервисам.

@Configuration
public class UniversityConfig {
  
    @Bean
    @Primary //аннотация используется для предоставления более высокого предпочтения помеченному bean-компоненту, когда существует несколько bean-компонентов одного типа.
    public Person student() {
        return new Student();
    }
    
####################################################################################################################  
####################################################################################################################
####################################################################################################################
####################################################################################################################
####################################################################################################################
MySQL

CREATE DATABASE usersdb;

USE usersdb;
CREATE TABLE users (
    id INTEGER AUTO_INCREMENT PRIMARY KEY, 
    firstname VARCHAR(30), 
    age INTEGER
);
INSERT INTO users (firstname, age) VALUES ('Tom', 34);

И в конце получим все данные из таблицы users с помощью следующих команд:
USE usersdb;
SELECT * FROM users;

Удаление базы данных
DROP DATABASE [IF EXISTS] имя_базы_даных;

Создание таблицы
CREATE TABLE название_таблицы
(название_столбца1 тип_данных атрибуты_столбца1, 
 название_столбца2 тип_данных атрибуты_столбца2,
 ................................................
 название_столбцаN тип_данных атрибуты_столбцаN,
 атрибуты_уровня_таблицы
)

CREATE DATABASE productsdb;
 
USE productsdb;
 
CREATE TABLE Customers
(
    Id INT,
    Age INT,
    FirstName VARCHAR(20),
    LastName VARCHAR(20)
);

Переименование таблиц
RENAME TABLE старое_название TO новое_название;
RENAME TABLE Customers TO Clients;

Полная очистка данных
TRUNCATE TABLE Clients;

Удаление таблиц
DROP TABLE Clients;

Типы данных MySQL
Символьные типы
CHAR: представляет строку фиксированной длины.

Длина хранимой строки указывается в скобках, например, CHAR(10) - строка из десяти символов. И если в таблицу в данный столбец сохраняется строка из 6 символов (то есть меньше установленной длины в 10 символов), то строка дополняется 4 пробелами и в итоге все равно будет занимать 10 символов

Тип CHAR может хранить до 255 байт.

VARCHAR: представляет строку переменной длины.

Длина хранимой строки также указыватся в скобках, например, VARCHAR(10). Однако в отличие от CHAR хранимая строка будет занимать именно столько места, сколько необходимо. Например, если определенная длина в 10 символов, но в столбец сохраняется строка в 6 символов, то хранимая строка так и будет занимать 6 символов плюс дополнительный байт, который хранит длину строки.

Всего тип VARCHAR может хранить до 65535 байт.

Ряд дополнительных типов данных представляют текст неопределенной длины:

TINYTEXT: представляет текст длиной до 255 байт.

TEXT: представляет текст длиной до 65 КБ.

MEDIUMTEXT: представляет текст длиной до 16 МБ

LARGETEXT: представляет текст длиной до 4 ГБ

Числовые типы
TINYINT: представляет целые числа от -128 до 127, занимает 1 байт

BOOL: фактически не представляет отдельный тип, а является лишь псевдонимом для типа TINYINT(1) и может хранить два значения 0 и 1. Однако данный тип может также в качестве значения принимать встроенные константы TRUE (представляет число 1) и FALSE (предоставляет число 0).

Также имеет псевдоним BOOLEAN.

TINYINT UNSIGNED: представляет целые числа от 0 до 255, занимает 1 байт

SMALLINT: представляет целые числа от -32768 до 32767, занимает 2 байтa

SMALLINT UNSIGNED: представляет целые числа от 0 до 65535, занимает 2 байтa

MEDIUMINT: представляет целые числа от -8388608 до 8388607, занимает 3 байта

MEDIUMINT UNSIGNED: представляет целые числа от 0 до 16777215, занимает 3 байта

INT: представляет целые числа от -2147483648 до 2147483647, занимает 4 байта

INT UNSIGNED: представляет целые числа от 0 до 4294967295, занимает 4 байта

BIGINT: представляет целые числа от -9 223 372 036 854 775 808 до 9 223 372 036 854 775 807, занимает 8 байт

BIGINT UNSIGNED: представляет целые числа от 0 до 18 446 744 073 709 551 615, занимает 8 байт

DECIMAL: хранит числа с фиксированной точностью. Данный тип может принимать два параметра precision и scale: DECIMAL(precision, scale).

Параметр precision представляет максимальное количество цифр, которые может хранить число. Это значение должно находиться в диапазоне от 1 до 65.

Параметр scale представляет максимальное количество цифр, которые может содержать число после запятой. Это значение должно находиться в диапазоне от 0 до значения параметра precision. По умолчанию оно равно 0.

Например, в определении следующего столбца:
salary DECIMAL(5,2)
Число 5 - precision, а число 2 - scale, поэтому данный столбец может хранить значения из диапазона от -999.99 до 999.99.

Размер данных в байтах для DECIMAL зависит от хранимого значения.

Данный тип также имеет псевдонимы NUMERIC, DEC, FIXED.

FLOAT: хранит дробные числа с плавающей точкой одинарной точности от -3.4028 * 1038 до 3.4028 * 1038, занимает 4 байта

Может принимать форму FLOAT(M,D), где M - общее количество цифр, а D - количество цифр после запятой

.
DOUBLE: хранит дробные числа с плавающей точкой двойной точности от -1.7976 * 10308 до 1.7976 * 10308, занимает 8 байт. Также может принимать форму DOUBLE(M,D), где M - общее количество цифр, а D - количество цифр после запятой.

Данный тип также имеет псевдонимы REAL и DOUBLE PRECISION, которые можно использовать вместо DOUBLE.

Типы для работы с датой и временем
DATE: хранит даты с 1 января 1000 года до 31 деабря 9999 года (c "1000-01-01" до "9999-12-31"). По умолчанию для хранения используется формат yyyy-mm-dd. Занимает 3 байта.

TIME: хранит время от -838:59:59 до 838:59:59. По умолчанию для хранения времени применяется формат "hh:mm:ss". Занимает 3 байта.

DATETIME: объединяет время и дату, диапазон дат и времени - с 1 января 1000 года по 31 декабря 9999 года (с "1000-01-01 00:00:00" до "9999-12-31 23:59:59"). Для хранения по умолчанию используется формат "yyyy-mm-dd hh:mm:ss". Занимает 8 байт

TIMESTAMP: также хранит дату и время, но в другом диапазоне: от "1970-01-01 00:00:01" UTC до "2038-01-19 03:14:07" UTC. Занимает 4 байта

YEAR: хранит год в виде 4 цифр. Диапазон доступных значений от 1901 до 2155. Занимает 1 байт.

Составные типы
ENUM: хранит одно значение из списка допустимых значений. Занимает 1-2 байта

SET: может хранить несколько значений (до 64 значений) из некоторого списка допустимых значений. Занимает 1-8 байт.

Бинарные типы
TINYBLOB: хранит бинарные данные в виде строки длиной до 255 байт.

BLOB: хранит бинарные данные в виде строки длиной до 65 КБ.

MEDIUMBLOB: хранит бинарные данные в виде строки длиной до 16 МБ

LARGEBLOB: хранит бинарные данные в виде строки длиной до 4 ГБ

PRIMARY KEY
Атрибут PRIMARY KEY задает первичный ключ таблицы.
USE productsdb;
 
CREATE TABLE Customers
(
    Id INT PRIMARY KEY,
    Age INT,
    FirstName VARCHAR(20),
    LastName VARCHAR(20)
);

AUTO_INCREMENT
Атрибут AUTO_INCREMENT позволяет указать, что значение столбца будет автоматически увеличиваться при добавлении новой строки. Данный атрибут работает для столбцов, которые представляют целочисленный тип или числа с плавающей точкой.
CREATE TABLE Customers
(
    Id INT PRIMARY KEY AUTO_INCREMENT,
    Age INT,
    FirstName VARCHAR(20),
    LastName VARCHAR(20)
);

UNIQUE
Атрибут UNIQUE указывает, что столбец может хранить только уникальные значения.
CREATE TABLE Customers
(
    Id INT PRIMARY KEY AUTO_INCREMENT,
    Age INT,
    FirstName VARCHAR(20),
    LastName VARCHAR(20),
    Phone VARCHAR(13) UNIQUE
);

NULL и NOT NULL
Чтобы указать, может ли столбец принимать значение NULL, при определении столбца ему можно задать атрибут NULL или NOT NULL. Если этот атрибут явным образом не будет использован, то по умолчанию столбец будет допускать значение NULL. Исключением является тот случай, когда столбец выступает в роли первичного ключа - в этом случае по умолчанию столбец имеет значение NOT NULL.
CREATE TABLE Customers
(
    Id INT PRIMARY KEY AUTO_INCREMENT,
    Age INT,
    FirstName VARCHAR(20) NOT NULL,
    LastName VARCHAR(20) NOT NULL,
    Email VARCHAR(30) NULL,
    Phone VARCHAR(20) NULL
);

DEFAULT
Атрибут DEFAULT определяет значение по умолчанию для столбца. Если при добавлении данных для столбца не будет предусмотрено значение, то для него будет использоваться значение по умолчанию.
CREATE TABLE Customers
(
    Id INT PRIMARY KEY AUTO_INCREMENT,
    Age INT DEFAULT 18,
    FirstName VARCHAR(20) NOT NULL,
    LastName VARCHAR(20) NOT NULL,
    Email VARCHAR(30) NOT NULL UNIQUE,
    Phone VARCHAR(20) NOT NULL UNIQUE
);

CHECK
Атрибут CHECK задает ограничение для диапазона значений, которые могут храниться в столбце. Для этого после CHECK указывается в скобках условие, которому должен соответствовать столбец или несколько столбцов. Например, возраст клиентов не может быть меньше 0 или больше 100:
CREATE TABLE Customers
(
    Id INT AUTO_INCREMENT,
    Age INT DEFAULT 18 CHECK(Age >0 AND Age < 100),
    FirstName VARCHAR(20) NOT NULL,
    LastName VARCHAR(20) NOT NULL,
    Email VARCHAR(30) CHECK(Email !=''),
    Phone VARCHAR(20) CHECK(Phone !='')
);

Для соединения условий используется ключевое слово AND. Условия можно задать в виде операций сравнения больше (>), меньше (<), не равно (!=).
Также CHECK можно использовать на уровне таблицы:
CHECK((Age >0 AND Age<100) AND (Email !='') AND (Phone !=''))

Оператор CONSTRAINT. Установка имени ограничений
С помощью ключевого слова CONSTRAINT можно задать имя для ограничений. Они указываются после ключевого слова CONSTRAINT перед атрибутами на уровне таблицы:
CREATE TABLE Customers
(
    Id INT AUTO_INCREMENT,
    Age INT,
    FirstName VARCHAR(20) NOT NULL,
    LastName VARCHAR(20) NOT NULL,
    Email VARCHAR(30),
    Phone VARCHAR(20) NOT NULL,
    CONSTRAINT customers_pk PRIMARY KEY(Id),
    CONSTRAINT customer_phone_uq UNIQUE(Phone),
    CONSTRAINT customer_age_chk CHECK(Age >0 AND Age<100)
);

Внешние ключи FOREIGN KEY
Внешние ключи позволяют установить связи между таблицами. Внешний ключ устанавливается для столбцов из зависимой, подчиненной таблицы, и указывает на один из столбцов из главной таблицы. Как правило, внешний ключ указывает на первичный ключ из связанной главной таблицы.

Общий синтаксис установки внешнего ключа на уровне таблицы:
[CONSTRAINT имя_ограничения]
FOREIGN KEY (столбец1, столбец2, ... столбецN) 
REFERENCES главная_таблица (столбец_главной_таблицы1, столбец_главной_таблицы2, ... столбец_главной_таблицыN)
[ON DELETE действие]
[ON UPDATE действие]
Для создания ограничения внешнего ключа после FOREIGN KEY указывается столбец таблицы, который будет представляет внешний ключ. А после ключевого слова REFERENCES указывается имя связанной таблицы, а затем в скобках имя связанного столбца, на который будет указывать внешний ключ. После выражения REFERENCES идут выражения ON DELETE и ON UPDATE, которые задают действие при удалении и обновлении строки из главной таблицы соответственно.
CREATE TABLE Customers
(
    Id INT PRIMARY KEY AUTO_INCREMENT,
    Age INT, 
    FirstName VARCHAR(20) NOT NULL,
    LastName VARCHAR(20) NOT NULL,
    Phone VARCHAR(20) NOT NULL UNIQUE
);
 
CREATE TABLE Orders
(
    Id INT PRIMARY KEY AUTO_INCREMENT,
    CustomerId INT,
    CreatedAt Date,
    FOREIGN KEY (CustomerId)  REFERENCES Customers (Id)
);

ON DELETE и ON UPDATE
С помощью выражений ON DELETE и ON UPDATE можно установить действия, которые выполняются соответственно при удалении и изменении связанной строки из главной таблицы. В качестве действия могут использоваться следующие опции:

CASCADE: автоматически удаляет или изменяет строки из зависимой таблицы при удалении или изменении связанных строк в главной таблице.

SET NULL: при удалении или обновлении связанной строки из главной таблицы устанавливает для столбца внешнего ключа значение NULL. (В этом случае столбец внешнего ключа должен поддерживать установку NULL)

RESTRICT: отклоняет удаление или изменение строк в главной таблице при наличии связанных строк в зависимой таблице.

NO ACTION: то же самое, что и RESTRICT.

SET DEFAULT: при удалении связанной строки из главной таблицы устанавливает для столбца внешнего ключа значение по умолчанию, которое задается с помощью атрибуты DEFAULT. Несмотря на то, что данная опция в принципе доступна, однако движок InnoDB не поддерживает данное выражение.

Каскадное удаление
Каскадное удаление позволяет при удалении строки из главной таблицы автоматически удалить все связанные строки из зависимой таблицы. Для этого применяется опция CASCADE:

CREATE TABLE Orders
(
    Id INT PRIMARY KEY AUTO_INCREMENT,
    CustomerId INT,
    CreatedAt Date,
    FOREIGN KEY (CustomerId) REFERENCES Customers (Id) ON DELETE CASCADE
);

Установка NULL
При установки для внешнего ключа опции SET NULL необходимо, чтобы столбец внешнего ключа допускал значение NULL:
CREATE TABLE Orders
(
    Id INT PRIMARY KEY AUTO_INCREMENT,
    CustomerId INT,
    CreatedAt Date,
    FOREIGN KEY (CustomerId) REFERENCES Customers (Id) ON DELETE SET NULL
);

Изменение таблиц и столбцов
Если таблица уже была ранее создана, и ее необходимо изменить, то для этого применяется команда ALTER TABLE. Ее сокращенный формальный синтаксис:
ALTER TABLE название_таблицы 
{ ADD название_столбца тип_данных_столбца [атрибуты_столбца] | 
  DROP COLUMN название_столбца |
  MODIFY COLUMN название_столбца тип_данных_столбца [атрибуты_столбца] |
  ALTER COLUMN название_столбца SET DEFAULT значение_по_умолчанию |
  ADD [CONSTRAINT] определение_ограничения |
  DROP [CONSTRAINT] имя_ограничения}
Добавление нового столбца
Добавим в таблицу Customers новый столбец Address:
ALTER TABLE Customers
ADD Address VARCHAR(50) NULL;
В данном случае столбец Address имеет тип VARCHAR и для него определен атрибут NULL.
Удаление столбца
Удалим столбец Address из таблицы Customers:
ALTER TABLE Customers
DROP COLUMN Address;  
  
Добавление и удаление внешнего ключа
Пусть изначально в базе данных будут добавлены две таблицы, никак не связанные:
CREATE TABLE Customers
(
    Id INT PRIMARY KEY AUTO_INCREMENT,
    Age INT, 
    FirstName VARCHAR(20) NOT NULL,
    LastName VARCHAR(20) NOT NULL
);
CREATE TABLE Orders
(
    Id INT PRIMARY KEY AUTO_INCREMENT,
    CustomerId INT,
    CreatedAt Date
);
Добавим ограничение внешнего ключа к столбцу CustomerId таблицы Orders:
ALTER TABLE Orders
ADD FOREIGN KEY(CustomerId) REFERENCES Customers(Id);
При добавлении ограничений мы можем указать для них имя, используя оператор CONSTRAINT, после которого указывается имя ограничения:
ALTER TABLE Orders
ADD CONSTRAINT orders_customers_fk 
FOREIGN KEY(CustomerId) REFERENCES Customers(Id);
В данном случае ограничение внешнего ключа называется orders_customers_fk. Затем по этому имени мы можем удалить ограничение:
ALTER TABLE Orders
DROP FOREIGN KEY orders_customers_fk;
Добавление и удаление первичного ключа
Добавим в таблицу Products первичный ключ:
CREATE TABLE Products
(
    Id INT,
    Model VARCHAR(20)
);
 
ALTER TABLE Products
ADD PRIMARY KEY (Id);  


Добавление данных. Команда INSERT
INSERT [INTO] имя_таблицы [(список_столбцов)] VALUES (значение1, значение2, ... значениеN)
INSERT Products(ProductName, Manufacturer, ProductCount, Price) 
VALUES ('iPhone X', 'Apple', 5, 76000);

Множественное добавление
Также мы можем добавить сразу несколько строк:
INSERT Products(ProductName, Manufacturer, Price, ProductCount) 
VALUES
('iPhone 8', 'Apple', 51000, 3),
('P20 Lite', 'Huawei', 34000, 4),
('Galaxy S8', 'Samsung', 46000, 2);

Выборка данных. Команда SELECT
SELECT список_столбцов FROM имя_таблицы
SELECT * FROM Products;
SELECT ProductName, Price FROM Products;

С помощью оператора AS можно изменить название выходного столбца или определить его псевдоним:
SELECT ProductName AS Title, Price * ProductCount AS TotalSum FROM Products;

Фильтрация данных. Оператор WHERE
WHERE условие
=: сравнение на равенство
!=: сравнение на неравенство
<>: сравнение на неравенство
<: меньше чем
>: больше чем
<=: меньше чем или равно
>=: больше чем или равно
SELECT * FROM Products WHERE Manufacturer = 'Samsung';
AND: операция логического И. Она объединяет два выражения:
OR: операция логического ИЛИ. Она также объединяет два выражения:
NOT: операция логического отрицания. Если выражение в этой операции ложно, то общее условие истинно.
SELECT * FROM Products WHERE Manufacturer = 'Samsung' OR Price > 50000
С помощью скобок можно переопределить приоритет операций:
SELECT * FROM Products WHERE Manufacturer ='Samsung' OR NOT (Price > 30000 AND ProductCount > 2);

Обновление данных. Команда UPDATE
Команда UPDATE применяется для обновления уже имеющихся строк. Она имеет следующий формальный синтаксис:
UPDATE имя_таблицы SET столбец1 = значение1, столбец2 = значение2, ... столбецN = значениеN [WHERE условие_обновления]
UPDATE Products SET Price = Price + 3000;
Используем выражение WHERE и изменим название производителя с "Samsung" на "Samsung Inc.":
UPDATE Products SET Manufacturer = 'Samsung Inc.' WHERE Manufacturer = 'Samsung';

Удаление данных. Команда DELETE
DELETE FROM имя_таблицы [WHERE условие_удаления]
DELETE FROM Products WHERE Manufacturer='Huawei';

Выборка уникальных значений. Оператор DISTINCT
С помощью оператора DISTINCT можно выбрать уникальные данные по определенным столбцам.
SELECT DISTINCT Manufacturer FROM Products;

Операторы фильтрации
Оператор IN
Оператор IN определяет набор значений, которые должны иметь столбцы:
WHERE выражение [NOT] IN (выражение)
SELECT * FROM Products WHERE Manufacturer IN ('Samsung', 'HTC', 'Huawei');
Оператор NOT, наоборот, позволяет выбрать все строки, столбцы которых не имеют определенных значений:
SELECT * FROM Products WHERE Manufacturer NOT IN ('Samsung', 'HTC', 'Huawei');
Оператор BETWEEN определяет диапазон значений с помощью начального и конечного значения, которому должно соответствовать выражение:
WHERE выражение [NOT] BETWEEN начальное_значение AND конечное_значение
SELECT * FROM Products WHERE Price BETWEEN 20000 AND 50000;
Операторы LIKE и REGEXP
WHERE выражение [NOT] LIKE шаблон_строки
Для определения шаблона могут применяться ряд специальных символов подстановки:
%: соответствует любой подстроке, которая может иметь любое количество символов, при этом подстрока может и не содержать ни одного символа
Например, выражение WHERE ProductName LIKE 'Galaxy%' соответствует таким значениям как "Galaxy Ace 2" или "Galaxy S7"
_: соответствует любому одиночному символу
Например, выражение WHERE ProductName LIKE 'Galaxy S_' соответствует таким значениям как "Galaxy S7" или "Galaxy S8".
Применим оператор LIKE:
SELECT * FROM Products WHERE ProductName LIKE 'iPhone%';
REGEXP позволяет задать регулярное выражение, которому должно соответствовать значение столбца. В этом плане REGEXP представляет более изощренный и комплексный способ фильтрации, нежели оператор LIKE. REGEXP имеет похожий синтаксис:
WHERE выражение [NOT] REGEXP регулярное выражение
Регулярное выражение может принимать следующие специальные символы:
^: указывает на начало строки
$: указывает на конец строки
.: соответствует любому одиночному символу
[символы]: соответствует любому одиночному символу из скобок
[начальный_символ-конечный_символ]: соответствует любому одиночному символу из диапазона символов
|: отделяет два шаблона строки, и значение должно соответствовать одну из этих шаблонов
Примеры REGEXP:
WHERE ProductName REGEXP 'Phone': строка должна содержать "Phone", например, iPhone X, Nokia Phone N, iPhone
WHERE ProductName REGEXP '^Phone': строка должна начинаться с "Phone", например, Phone 34, PhoneX
WHERE ProductName REGEXP 'Phone$': строка должна заканчиваться на "Phone", например, iPhone, Nokia Phone
WHERE ProductName REGEXP 'iPhone [78]';: строка должна содержать либо iPhone 7, либо iPhone 8
WHERE ProductName REGEXP 'iPhone [6-8]';: строка должна содержать либо iPhone 6, либо iPhone 7, либо iPhone 8
Например, найдем товары, названия которых содержат либо "Phone", либо "Galaxy":
SELECT * FROM Products WHERE ProductName REGEXP 'Phone|Galaxy';

IS NULL
Оператор IS NULL позволяет выбрать все строки, столбцы которых имеют значение NULL:
SELECT * FROM Products WHERE ProductCount IS NULL;

Сортировка. ORDER BY
Оператор ORDER BY сортируют значения по одному или нескольких столбцам. Например, упорядочим выборку из таблицы Products по столбцу Price:
SELECT * FROM Products ORDER BY Price;
В качестве критерия сортировки также можно использовать сложно выражение на основе столбцов:
SELECT ProductName, Price, ProductCount FROM Products ORDER BY ProductCount * Price;
Сортировка по убыванию
По умолчанию данные сортируются по возрастанию, однако с помощью оператора DESC можно задать сортировку по убыванию.
SELECT ProductName, ProductCount FROM Products ORDER BY ProductCount DESC;
По умолчанию вместо DESC используется оператор ASC, который сортирует по возрастанию:
Сотировка по нескольким столбцам
При сортировке сразу по нескольким столбцам все эти столбцы указываются через запятую после оператора ORDER BY:
SELECT ProductName, Price, Manufacturer FROM Products ORDER BY Manufacturer, ProductName;
Здесь строки сначала сортируются по столбцу Manufacturer по возрастанию. Затем если есть две строки, в которых столбец Manufacturer имеет одинаковое значение, то они сортируются по столбцу ProductName также по возрастанию.

Получение диапазона строк. Оператор LIMIT
Оператор LIMIT позволяет извлечь определенное количество строк и имеет следующий синтаксис:
LIMIT [offset,] rowcount
SELECT * FROM Products LIMIT 3;
Теперь используем второй параметр и укажем смещение, с которой должна происходить выборка:
SELECT * FROM Products LIMIT 2, 3;
В данном случае пропускаются две первые строки и извлекаются следующие 3 строки:

Выборка уникальных значений. Оператор DISTINCT
С помощью оператора DISTINCT можно выбрать уникальные данные по определенным столбцам.
К примеру, разные товары могут иметь одних и тех же производителей
SELECT Manufacturer FROM Products;
Однако при таком запросе производители повторяются. Теперь применим оператор DISTINCT для выборки уникальных значений:
SELECT DISTINCT Manufacturer FROM Products;
SELECT DISTINCT Manufacturer, ProductCount FROM Products;
В данном случае для выборки используются столбцы Manufacturer и ProductCount. Из пяти строк только для двух строк эти столбцы имеют повторяющиеся значения. Поэтому в выборке будет 4 строки

Группировка
SELECT столбцы
FROM таблица
[WHERE условие_фильтрации_строк]
[GROUP BY столбцы_для_группировки]
[HAVING условие_фильтрации_групп]
[ORDER BY столбцы_для_сортировки]
GROUP BY
Оператор GROUP BY определяет, как строки будут группироваться. Например, сгруппируем товары по производителю
SELECT Manufacturer, COUNT(*) AS ModelsCount FROM Products GROUP BY Manufacturer
Первый столбец в выражении SELECT - Manufacturer представляет название группы, а второй столбец - ModelsCount представляет результат функции Count, которая вычисляет количество строк в группе.
Фильтрация групп. HAVING
Например, найдем все группы товаров по производителям, для которых определено более 1 модели:
SELECT Manufacturer, COUNT(*) AS ModelsCount FROM Products GROUP BY Manufacturer HAVING COUNT(*) > 1

Подзапросы
Подзапросы представляют выражения SELECT, которые встроены в другие запросы SQL. Рассмотрим простейший пример применения подзапросов.
INSERT INTO Orders (ProductId, CreatedAt, ProductCount, Price) VALUES
( 
    (SELECT Id FROM Products WHERE ProductName='Galaxy S8'),
    '2018-05-21', 
    2, 
    (SELECT Price FROM Products WHERE ProductName='Galaxy S8')
),
( 
    (SELECT Id FROM Products WHERE ProductName='iPhone X'),
    '2018-05-23',  
    1, 
    (SELECT Price FROM Products WHERE ProductName='iPhone X')
);

Получение набора значений
При использовании в операторах сравнения подзапросы должны возвращать одно скалярное значение. Но иногда возникает необходимость получить набор значений. Чтобы при использовании в операторах сравнения подзапрос мог возвращать набор значений, перед ним необходимо использовать один из операторов: ALL, SOME или ANY.
SELECT * FROM Products WHERE Price < ALL(SELECT Price FROM Products WHERE Manufacturer='Apple')

Оператор EXISTS
Оператор EXISTS проверяет, возвращает ли подзапрос какое-либо значение. Как правило, этот оператор используется для индикации того, что как минимум одна строка в таблице удовлетворяет некоторому условию. Поскольку возвращения набора строк не происходит, то подзапросы с подобным оператором выполняются довольно быстро.
WHERE [NOT] EXISTS (подзапрос)
SELECT * FROM Products WHERE EXISTS  (SELECT * FROM Orders WHERE Orders.ProductId = Products.Id)
или
SELECT * FROM Products WHERE NOT EXISTS (SELECT * FROM Orders WHERE Products.Id = Orders.ProductId)

Соединение таблиц
Неявное соединение таблиц
SELECT * FROM Orders, Customers;
При такой выборке каждая строка из таблицы Orders будет соединяться с каждой строкой из таблицы Customers. То есть, получится перекрестное соединение. Например, в Orders три строки, а в Customers то же три строки, значит мы получим 3 * 3 = 9 строк:
SELECT * FROM Orders, Customers WHERE Orders.CustomerId = Customers.Id;

SQL LEFT JOIN Keyword
The LEFT JOIN keyword returns all records from the left table (table1), and the matching records from the right table (table2). The result is 0 records from the right side, if there is no match.
SELECT column_name(s)
FROM table1
LEFT JOIN table2
ON table1.column_name = table2.column_name;

SQL RIGHT JOIN Keyword
The RIGHT JOIN keyword returns all records from the right table (table2), and the matching records from the left table (table1). The result is 0 records from the left side, if there is no match.
SELECT column_name(s)
FROM table1
RIGHT JOIN table2
ON table1.column_name = table2.column_name;
example
SELECT Orders.OrderID, Employees.LastName, Employees.FirstName
FROM Orders
RIGHT JOIN Employees ON Orders.EmployeeID = Employees.EmployeeID
ORDER BY Orders.OrderID;

SQL FULL OUTER JOIN Keyword
The FULL OUTER JOIN keyword returns all records when there is a match in left (table1) or right (table2) table records.
Tip: FULL OUTER JOIN and FULL JOIN are the same.
FULL OUTER JOIN Syntax
SELECT column_name(s)
FROM table1
FULL OUTER JOIN table2
ON table1.column_name = table2.column_name
WHERE condition;

Inner Join
В прошлой теме было рассмотрено неявное соединение таблиц с помощью простой выборки путем сведения данных. Но, как правило, более распространенный подход соединения данных из разных таблиц представляет применение оператора JOIN. Общий формальный синтаксис применения оператора INNER JOIN:
SELECT столбцы
FROM таблица1
    [INNER] JOIN таблица2
    ON условие1
    [[INNER] JOIN таблица3
    ON условие2]
После оператора JOIN идет название второй таблицы, из которой надо добавить данные в выборку. Перед JOIN может использоваться необязательное ключевое слово INNER. Его наличие или отсутствие ни на что не влияет. Затем после ключевого слова ON указывается условие соединения. Это условие устанавливает, как две таблицы будут сравниваться. В большинстве случаев для соединения применяется первичный ключ главной таблицы и внешний ключ зависимой таблицы.
Используя JOIN, выберем все заказы и добавим к ним информацию о товарах:
SELECT Orders.CreatedAt, Orders.ProductCount, Products.ProductName  FROM Orders JOIN Products ON Products.Id = Orders.ProductId;


Outer Join
В предыдущей теме рассматривля Inner Join или внутреннее соединение таблиц. Но также в MySQL мы можем использовать и так называемое внешнее соединение или Outer Join. В отличие от Inner Join внешнее соединение возвращает все строки одной или двух таблиц, которые участвуют в соединении.
Outer Join имеет следующий формальный синтаксис:
SELECT столбцы
FROM таблица1
    {LEFT|RIGHT} [OUTER] JOIN таблица2 ON условие1
    [{LEFT|RIGHT} [OUTER] JOIN таблица3 ON условие2]...
Перед оператором JOIN указывается одно из ключевых слов LEFT или RIGHT, которые определяют тип соединения:
LEFT: выборка будет содержать все строки из первой или левой таблицы
RIGHT: выборка будет содержать все строки из второй или правой таблицы    
Также перед оператором JOIN может указываться ключевое слово OUTER, но его применение необязательно. Далее после JOIN указывается присоединяемая таблица, а затем идет условие соединения.
Например, соединим таблицы Orders и Customers:
SELECT FirstName, CreatedAt, ProductCount, Price, ProductId  FROM Orders LEFT JOIN Customers ON Orders.CustomerId = Customers.Id
Таблица Orders является первой или левой таблицей, а таблица Customers - правой таблицей. Поэтому, так как здесь используется выборка по левой таблице, то вначале будут выбираться все строки из Orders, а затем к ним по условию Orders.CustomerId = Customers.Id будут добавляться связанные строки из Customers.
По вышеприведенному результату может показаться, что левостороннее соединение аналогично INNER Join, но это не так. Inner Join объединяет строки из дух таблиц при соответствии условию. Если одна из таблиц содержит строки, которые не соответствуют этому условию, то данные строки не включаются в выходную выборку. Left Join выбирает все строки первой таблицы и затем присоединяет к ним строки правой таблицы. К примеру, возьмем таблицу Customers и добавим к покупателям информацию об их заказах:
#INNER JOIN
SELECT FirstName, CreatedAt, ProductCount, Price 
FROM Customers JOIN Orders 
ON Orders.CustomerId = Customers.Id;
 
#LEFT JOIN
SELECT FirstName, CreatedAt, ProductCount, Price 
FROM Customers LEFT JOIN Orders 
ON Orders.CustomerId = Customers.Id;

В случае с LEFT JOIN MySQL выбирает сначала всех покупателей из таблицы Customers, затем сопоставляет их с заказами из таблицы Orders через условие Orders.CustomerId = Customers.Id. Однако не у всех покупателей есть заказы. В этом случае покупателю для соответствующих столбцов устанавливаются значения NULL.
SELECT FirstName, CreatedAt, ProductCount, Price 
FROM Customers RIGHT JOIN Orders 
ON Orders.CustomerId = Customers.Id;

UNION
Оператор UNION позволяет обединить две однотипных выборки. Эти выборки могут быть из разных таблиц или из одной и той же таблицы. Формальный синтаксис объединения:
SELECT_выражение1
UNION [ALL] SELECT_выражение2
[UNION [ALL] SELECT_выражениеN]
Здесь мы можем заметить, что обе таблицы, несмотря на наличие различных данных, могут характеризоваться двумя общими атрибутами - именем (FirstName) и фамилией (LastName). Выберем сразу всех клиентов банка и его сотрудников из обеих таблиц:
SELECT FirstName, LastName 
FROM Customers
UNION SELECT FirstName, LastName FROM Employees;

Встроенные функции
Функции для работы со строками
Для работы со строка в MySQL определен ряд встроенных функций:
CONCAT: объединяет строки. В качестве параметра принимает от 2-х и более строк, которые надо соединить:
SELECT CONCAT('Tom', ' ', 'Smith')  -- Tom Smith
При этом в функцию можно передавать не только непосредственно строки, но и числа, даты - они будут преобразовываться в строки и также объединяться.
CONCAT_WS: также объединяет строки, но в качестве первого параметра принимает разделитель, который будет соединять строки:
SELECT CONCAT_WS(' ', 'Tom', 'Smith', 'Age:', 34)  -- Tom Smith Age: 34
LENGTH: возвращает количество символов в строке. В качестве параметра в функцию передается строка, для которой надо найти длину:
SELECT LENGTH('Tom Smith')  -- 9
LTRIM: удаляет начальные пробелы из строки. В качестве параметра принимает строку:
SELECT LTRIM('  Apple')
RTRIM: удаляет конечные пробелы из строки. В качестве параметра принимает строку:
SELECT RTRIM(' Apple    ')
TRIM: удаляет начальные и конечные пробелы из строки. В качестве параметра принимает строку:
SELECT TRIM('  Tom Smith   ')
С помощью дополнительного оператора можно задать где имеено удалить пробелы: BOTH (в начале и в конце), TRAILING (только в конце), LEADING (только в начале):
SELECT TRIM(BOTH FROM '  Tom Smith   ')
LOCATE(find, search [, start]): возвращает позицию первого вхождения подстроки find в строку search. Дополнительный параметр start позволяет установить позицию в строке search, с которой начинается поиск подстроки find. Если подстрока search не найдена, то возвращается 0:
SELECT LOCATE('om', 'Tom Smith');       -- 2
SELECT LOCATE('m', 'Tom Smith');        -- 3
SELECT LOCATE('m', 'Tom Smith', 4);     -- 6
SELECT LOCATE('mig', 'Tom Smith');      -- 0
LEFT: вырезает с начала строки определенное количество символов. Первый параметр функции - строка, а второй - количество символов, которые надо вырезать сначала строки:
SELECT LEFT('Apple', 3) -- App
RIGHT: вырезает с конца строки определенное количество символов. Первый параметр функции - строка, а второй - количество символов, которые надо вырезать сначала строки:
SELECT RIGHT('Apple', 3)    -- ple
SUBSTRING(str, start [, length]): вырезает из строки str подстроку, начиная с позиции start. Третий необязательный параметр передает количество вырезаемых символов:
SELECT SUBSTRING('Galaxy S8 Plus', 8),          -- S8 Plus
(SELECT SUBSTRING('Galaxy S8 Plus', 8, 2) );    -- S8
SUBSTRING_INDEX(str, delimiter, count): вырезает из строки str подстроку. Параметр delimiter определяет разделитель внутри строки. А параметр count определяет, до какого вхождения разделителя надо вырезать подстроку. Если count положительный, то подстрока вырезается с начала, если count отрицательный, то с конца строки str:
SELECT SUBSTRING_INDEX('Galaxy S8 Plus', ' ', 1),           -- Galaxy
(SELECT SUBSTRING_INDEX('Galaxy S8 Plus', ' ', 2) ),        -- Galaxy S8
(SELECT SUBSTRING_INDEX('Galaxy S8 Plus', ' ', -2) );           -- S8 Plus
REPLACE(search, find, replace): заменяет в строке find подстроку search на подстроку replace. Первый параметр функции - строка, второй - подстрока, которую надо заменить, а третий - подстрока, на которую надо заменить:
SELECT REPLACE('Galaxy S8 Plus', 'S8 Plus', 'Note 8')   -- Galaxy Note 8
INSERT(str, start, length, insert): вставляет в строку str, заменяя length символов с позиции start подстрокой insert. Первый параметр функции - строка, второй - позиция, с которой надо заменить, третий - сколько символов с позиции start надо заменить вставляемой подстрокой, четвертый параметр - вставляемая подстрока:
SELECT INSERT('Galaxy S9', 8, 3, 'Note 9');   -- Galaxy Note 9
REVERSE: переворачивает строку наоборот:
SELECT REVERSE('123456789') -- 987654321
LOWER: переводит строку в нижний регистр:
SELECT LOWER('Apple')   -- apple
UPPER: переводит строку в верхний регистр
SELECT UPPER('Apple')   -- APPLE
SPACE: возвращает строку, которая содержит определенное количество пробелов
REPEATE(str, count): возвращает строку, которая содержит определенное количество повторов подстроки str. Количество повторов задается через параметр count.
SELECT REPEAT('ab', 5);   -- ababababab
LPAD(str, length, pad): добавляет слева от строки str некоторое количество символов, которые определены в параметре pad. Количество добавляемых символов вычисляется по формуле length - LENGTH(str). Если параметр length меньше длины строки str, то эта строка усекается до length символов.
SELECT LPAD('Tom Smith', 13, '*');   -- ****Tom Smith
RPAD(str, length, pad): добавляет справа от строки str некоторое количество символов, которые определены в параметре pad. Количество добавляемых символов вычисляется по формуле length - LENGTH(str). Если параметр length меньше длины строки str, то эта строка усекается до length символов.
SELECT RPAD('Tom Smith', 13, '*');   -- Tom Smith****

Функции для работы с числами
Для работы с числовыми данными MySQL предоставляет ряд функций:
ROUND: округляет число. В качестве первого параметра передается число. Второй параметр указывает на длину. Если длина представляет положительное число, то оно указывает, до какой цифры после запятой идет округление. Если длина представляет отрицательное число, то оно указывает, до какой цифры с конца числа до запятой идет округление
SELECT ROUND(1342.345, 2),      -- 1342.35
(SELECT ROUND(1342.345, -2));   -- 1300;
TRUNCATE: оставляет в дробной части определенное количество символов
SELECT TRUNCATE(1342.345, 2);       -- 1342.34
ABS: возвращает абсолютное значение числа.
SELECT ABS(-123)    -- 123
CEILING: возвращает наименьшее целое число, которое больше или равно текущему значению.
SELECT CEILING(-123.45),        -- -123
(SELECT CEILING(123.45));       -- 124
FLOOR: возвращает наибольшее целое число, которое меньше или равно текущему значению.
SELECT FLOOR(-123.45),      -- -124
(SELECT FLOOR(123.45));     -- 123
POWER: возводит число в определенную степень.
SELECT POWER(5, 2),     -- 25
(SELECT POWER(5, 3));       -- 125
SQRT: получает квадратный корень числа.
SELECT SQRT(225);       -- 15
SIGN: возвращает -1, если число меньше 0, и возвращает 1, если число больше 0. Если число равно 0, то возвращает 0.
SELECT SIGN(-5),        -- -1
(SELECT SIGN(7));       -- 1
RAND: генерирует случайное число с плавающей точкой в диапазоне от 0 до 1.
SELECT RAND();      -- 0.707365088352935
SELECT RAND();      -- 0.173808327956812

Функции для работы с датами и временем
MySQL имеет ряд встроенных функций для работы с датами и временем.
Получение даты и времени
Функции NOW(), SYSDATE(), CURRENT_TIMESTAMP() возвращают текущую локальную дату и время на основе системных часов в виде объекта datetime. Все три функции возвращают одинаковый результат
SELECT NOW();               -- 2018-05-25 21:34:55
SELECT SYSDATE();           -- 2018-05-25 21:34:55
SELECT CURRENT_TIMESTAMP(); -- 2018-05-25 21:32:55
Функции CURDATE и CURRENT_DATE возвращают текущую локальную дату в виде объекта date:
SELECT CURRENT_DATE();      -- 2018-05-25
SELECT CURDATE();           -- 2018-05-25
Функции CURTIME и CURRENT_TIME возвращают текущее время в виде объекта time:
SELECT CURRENT_TIME();  -- 20:47:45
SELECT CURTIME();       -- 20:47:45
UTC_DATE возвращает текущую локальную дату относительно GMT
SELECT UTC_DATE();      -- 2018-05-25
UTC_TIME возвращает текущее локальное время относительно GMT
SELECT UTC_TIME();      -- 17:47:45
Парсинг даты и времени
DAYOFMONTH(date) возвращает день месяца в виде числового значения
DAYOFWEEK(date) возвращает день недели в виде числового значения
DAYOFYEAR(date) возвращает номер дня в году
MONTH(date) возвращает месяц даты
YEAR(date) возвращает год из даты
QUARTER(date) возвращает номер квартала года
WEEK(date [, first]) возвращает номер недели года. Необязательный параметр позволяет задать стартовый день недели. Если этот параметр равен 1, то первым днем считается понедельник, иначе воскресенье
LAST_DAY(date) возвращает последний день месяца в виде даты
DAYNAME(date) возвращает название дня недели
MONTHNAME(date) возвращает название текущего месяца
HOUR(time) возвращает час времени
MINUTE(time) возвращает минуту времени
SECOND(time) возвращает секунду времени

Функции CASE, IF, IFNULL, COALESCE
CASE
Функция CASE проверяет истинность набора условий и в зависимости от результата проверки может возвращать тот или иной результат. Эта функция принимает следующую форму:
CASE
    WHEN условие_1 THEN результат_1
    WHEN условие_2 THEN результат_2
    .................................
    WHEN условие_N THEN условие_N
    [ELSE альтернативный_результат]
END

Функция IF
Функция IF в зависимости от результата условного выражения возвращает одно из двух значений. Общая форма функции выглядит следующим образом:
IF(условие, значение_1, значение_2)
SELECT ProductName, Manufacturer,
    IF(ProductCount > 3, 'Много товара', 'Мало товара')
FROM Products;

IFNULL
Функция IFNULL проверяет значение некоторого выражения. Если оно равно NULL, то функция возвращает значение, которое передается в качестве второго параметра:
IFNULL(выражение, значение)
И применим при получении данных функцию IFNULL:
SELECT FirstName, LastName,
        IFNULL(Phone, 'не определено') AS Phone,
        IFNULL(Email, 'неизвестно') AS Email
FROM Clients;

COALESCE
Функция COALESCE принимает список значений и возвращает первое из них, которое не равно NULL:
COALESCE(выражение_1, выражение_2, выражение_N)
Например, выберем из таблицы Clients пользователей и в контактах у них определим либо телефон, либо электронный адрес, если они не равны NULL:
SELECT FirstName, LastName,
        COALESCE(Phone, Email, 'не определено') AS Contacts
FROM Clients;










